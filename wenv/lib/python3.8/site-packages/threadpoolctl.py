
import os
import re
import sys
import ctypes
import textwrap
import warnings
from ctypes.util import find_library
from abc import ABC, abstractmethod

__version__ = "2.1.0"
__all__ = ["threadpool_limits", "threadpool_info"]


os.environ.setdefault("KMP_DUPLICATE_LIB_OK", "True")


_SYSTEM_UINT = ctypes.c_uint64 if sys.maxsize > 2**32 else ctypes.c_uint32
_SYSTEM_UINT_HALF = ctypes.c_uint32 if sys.maxsize > 2**32 else ctypes.c_uint16


class _dl_phdr_info(ctypes.Structure):
    _fields_ = [
        ("dlpi_addr",  _SYSTEM_UINT),       
        ("dlpi_name",  ctypes.c_char_p),    
        ("dlpi_phdr",  ctypes.c_void_p),    
        ("dlpi_phnum",  _SYSTEM_UINT_HALF)  
    ]


# The RTLD_NOLOAD flag for loading shared libraries is not defined on Windows.
try:
    _RTLD_NOLOAD = os.RTLD_NOLOAD
except AttributeError:
    _RTLD_NOLOAD = ctypes.DEFAULT_MODE


# List of the supported libraries. The items are indexed by the name of the
# class to instanciate to create the module objects. The items hold the
# possible prefixes of loaded shared objects, the name of the internal_api to
# call and the name of the user_api.
_SUPPORTED_MODULES = {
    "_OpenMPModule": {
        "user_api": "openmp",
        "internal_api": "openmp",
        "filename_prefixes": ("libiomp", "libgomp", "libomp", "vcomp")
    },
    "_OpenBLASModule": {
        "user_api": "blas",
        "internal_api": "openblas",
        "filename_prefixes": ("libopenblas",)
    },
    "_MKLModule": {
        "user_api": "blas",
        "internal_api": "mkl",
        "filename_prefixes": ("libmkl_rt", "mkl_rt")
    },
    "_BLISModule": {
        "user_api": "blas",
        "internal_api": "blis",
        "filename_prefixes": ("libblis",)
    }
}

# Helpers for the doc and test names
_ALL_USER_APIS = list(set(m["user_api"] for m in _SUPPORTED_MODULES.values()))
_ALL_INTERNAL_APIS = [m["internal_api"] for m in _SUPPORTED_MODULES.values()]
_ALL_PREFIXES = [prefix for m in _SUPPORTED_MODULES.values()
                 for prefix in m["filename_prefixes"]]
_ALL_BLAS_LIBRARIES = [m["internal_api"] for m in _SUPPORTED_MODULES.values()
                       if m["user_api"] == "blas"]
_ALL_OPENMP_LIBRARIES = list(
    _SUPPORTED_MODULES["_OpenMPModule"]["filename_prefixes"])


def _format_docstring(*args, **kwargs):
    def decorator(o):
        o.__doc__ = o.__doc__.format(*args, **kwargs)
        return o

    return decorator


@_format_docstring(USER_APIS=list(_ALL_USER_APIS),
                   INTERNAL_APIS=_ALL_INTERNAL_APIS)
def threadpool_info():
   
    return _ThreadpoolInfo(user_api=_ALL_USER_APIS).todicts()


@_format_docstring(
    USER_APIS=", ".join('"{}"'.format(api) for api in _ALL_USER_APIS),
    BLAS_LIBS=", ".join(_ALL_BLAS_LIBRARIES),
    OPENMP_LIBS=", ".join(_ALL_OPENMP_LIBRARIES))
class threadpool_limits:
    
    def __init__(self, limits=None, user_api=None):
        self._limits, self._user_api, self._prefixes = \
            self._check_params(limits, user_api)

        self._original_info = self._set_threadpool_limits()

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self.unregister()

    def unregister(self):
        if self._original_info is not None:
            for module in self._original_info:
                module.set_num_threads(module.num_threads)

    def get_original_num_threads(self):
      
        if self._original_info is not None:
            original_limits = self._original_info
        else:
            original_limits = _ThreadpoolInfo(user_api=self._user_api)

        num_threads = {}
        warning_apis = []

        for user_api in self._user_api:
            limits = [module.num_threads for module in
                      original_limits.get_modules("user_api", user_api)]
            limits = set(limits)
            n_limits = len(limits)

            if n_limits == 1:
                limit = limits.pop()
            elif n_limits == 0:
                limit = None
            else:
                limit = min(limits)
                warning_apis.append(user_api)

            num_threads[user_api] = limit

        if warning_apis:
            warnings.warn(
                "Multiple value possible for following user apis: "
                + ", ".join(warning_apis) + ". Returning the minimum.")

        return num_threads

    def _check_params(self, limits, user_api):
     
        if limits is None or isinstance(limits, int):
            if user_api is None:
                user_api = _ALL_USER_APIS
            elif user_api in _ALL_USER_APIS:
                user_api = [user_api]
            else:
                raise ValueError(
                    "user_api must be either in {} or None. Got "
                    "{} instead.".format(_ALL_USER_APIS, user_api))

            if limits is not None:
                limits = {api: limits for api in user_api}
            prefixes = []
        else:
            if isinstance(limits, list):
                # This should be a list of dicts of modules, for compatibility
                # with the result from threadpool_info.
                limits = {module["prefix"]: module["num_threads"]
                          for module in limits}
            elif isinstance(limits, _ThreadpoolInfo):
                # To set the limits from the modules of a _ThreadpoolInfo
                # object.
                limits = {module.prefix: module.num_threads
                          for module in limits}

            if not isinstance(limits, dict):
                raise TypeError("limits must either be an int, a list or a "
                                "dict. Got {} instead".format(type(limits)))

            # With a dictionary, can set both specific limit for given modules
            # and global limit for user_api. Fetch each separately.
            prefixes = [prefix for prefix in limits if prefix in _ALL_PREFIXES]
            user_api = [api for api in limits if api in _ALL_USER_APIS]

        return limits, user_api, prefixes

    def _set_threadpool_limits(self):
       
        if self._limits is None:
            return None

        modules = _ThreadpoolInfo(prefixes=self._prefixes,
                                  user_api=self._user_api)
        for module in modules:
         
            if module.prefix in self._limits:
                num_threads = self._limits[module.prefix]
            else:
                num_threads = self._limits[module.user_api]

            if num_threads is not None:
                module.set_num_threads(num_threads)
        return modules



@_format_docstring(
    PREFIXES=", ".join('"{}"'.format(prefix) for prefix in _ALL_PREFIXES),
    USER_APIS=", ".join('"{}"'.format(api) for api in _ALL_USER_APIS),
    BLAS_LIBS=", ".join(_ALL_BLAS_LIBRARIES),
    OPENMP_LIBS=", ".join(_ALL_OPENMP_LIBRARIES))
class _ThreadpoolInfo():
   
  
    _system_libraries = dict()
    
    _realpaths = dict()

    def __init__(self, user_api=None, prefixes=None,  modules=None):
        if modules is None:
            self.prefixes = [] if prefixes is None else prefixes
            self.user_api = [] if user_api is None else user_api

            self.modules = []
            self._load_modules()
            self._warn_if_incompatible_openmp()
        else:
            self.modules = modules

    def get_modules(self, key, values):
       
        if key == "user_api" and values is None:
            values = list(_ALL_USER_APIS)
        if not isinstance(values, list):
            values = [values]
        modules = [module for module in self.modules
                   if getattr(module, key) in values]
        return _ThreadpoolInfo(modules=modules)

    def todicts(self):
        
        return [module.todict() for module in self.modules]

    def __len__(self):
        return len(self.modules)

    def __iter__(self):
        yield from self.modules

    def __eq__(self, other):
        return self.modules == other.modules

    def _load_modules(self):
       
        if sys.platform == "darwin":
            self._find_modules_with_dyld()
        elif sys.platform == "win32":
            self._find_modules_with_enum_process_module_ex()
        else:
            self._find_modules_with_dl_iterate_phdr()

    def _find_modules_with_dl_iterate_phdr(self):
        
        libc = self._get_libc()
        if not hasattr(libc, "dl_iterate_phdr"):  # pragma: no cover
            return []

        # Callback function for `dl_iterate_phdr` which is called for every
        # module loaded in the current process until it returns 1.
        def match_module_callback(info, size, data):
            # Get the path of the current module
            filepath = info.contents.dlpi_name
            if filepath:
                filepath = filepath.decode("utf-8")

                
                self._make_module_from_path(filepath)
            return 0

        c_func_signature = ctypes.CFUNCTYPE(
            ctypes.c_int,  # Return type
            ctypes.POINTER(_dl_phdr_info), ctypes.c_size_t, ctypes.c_char_p)
        c_match_module_callback = c_func_signature(match_module_callback)

        data = ctypes.c_char_p(b"")
        libc.dl_iterate_phdr(c_match_module_callback, data)

    def _find_modules_with_dyld(self):
      
        libc = self._get_libc()
        if not hasattr(libc, "_dyld_image_count"):  # pragma: no cover
            return []

        n_dyld = libc._dyld_image_count()
        libc._dyld_get_image_name.restype = ctypes.c_char_p

        for i in range(n_dyld):
            filepath = ctypes.string_at(libc._dyld_get_image_name(i))
            filepath = filepath.decode("utf-8")

            
            self._make_module_from_path(filepath)

    def _find_modules_with_enum_process_module_ex(self):
        
        from ctypes.wintypes import DWORD, HMODULE, MAX_PATH

        PROCESS_QUERY_INFORMATION = 0x0400
        PROCESS_VM_READ = 0x0010

        LIST_MODULES_ALL = 0x03

        ps_api = self._get_windll("Psapi")
        kernel_32 = self._get_windll("kernel32")

        h_process = kernel_32.OpenProcess(
            PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
            False, os.getpid())
        if not h_process:  
            raise OSError("Could not open PID %s" % os.getpid())

        try:
            buf_count = 256
            needed = DWORD()
            
            while True:
                buf = (HMODULE * buf_count)()
                buf_size = ctypes.sizeof(buf)
                if not ps_api.EnumProcessModulesEx(
                        h_process, ctypes.byref(buf), buf_size,
                        ctypes.byref(needed), LIST_MODULES_ALL):
                    raise OSError("EnumProcessModulesEx failed")
                if buf_size >= needed.value:
                    break
                buf_count = needed.value // (buf_size // buf_count)

            count = needed.value // (buf_size // buf_count)
            h_modules = map(HMODULE, buf[:count])

            # Loop through all the module headers and get the module path
            buf = ctypes.create_unicode_buffer(MAX_PATH)
            n_size = DWORD()
            for h_module in h_modules:

                # Get the path of the current module
                if not ps_api.GetModuleFileNameExW(
                        h_process, h_module, ctypes.byref(buf),
                        ctypes.byref(n_size)):
                    raise OSError("GetModuleFileNameEx failed")
                filepath = buf.value

                # Store the module if it is supported and selected
                self._make_module_from_path(filepath)
        finally:
            kernel_32.CloseHandle(h_process)

    def _make_module_from_path(self, filepath):
      
        
        filepath = self._realpath(filepath)
     
        filename = os.path.basename(filepath).lower()

        
        for module_class, candidate_module in _SUPPORTED_MODULES.items():
           
            prefix = self._check_prefix(filename,
                                        candidate_module["filename_prefixes"])

            
            if prefix is None:
                continue

      
            user_api = candidate_module["user_api"]
            internal_api = candidate_module["internal_api"]
            if prefix in self.prefixes or user_api in self.user_api:
                module_class = globals()[module_class]
                module = module_class(filepath, prefix, user_api, internal_api)
                self.modules.append(module)

    def _check_prefix(self, library_basename, filename_prefixes):
        
        for prefix in filename_prefixes:
            if library_basename.startswith(prefix):
                return prefix
        return None

    def _warn_if_incompatible_openmp(self):
       
        if sys.platform != 'linux':
            
            return

        prefixes = [module.prefix for module in self.modules]
        msg = textwrap.dedent(
            """
            Found Intel OpenMP ('libiomp') and LLVM OpenMP ('libomp') loaded at
            the same time. Both libraries are known to be incompatible and this
            can cause random crashes or deadlocks on Linux when loaded in the
            same Python program.
            Using threadpoolctl may cause crashes or deadlocks. For more
            information and possible workarounds, please see
                https://github.com/joblib/threadpoolctl/blob/master/multiple_openmp.md
            """)
        if 'libomp' in prefixes and 'libiomp' in prefixes:
            warnings.warn(msg, RuntimeWarning)

    @classmethod
    def _get_libc(cls):
        
        libc = cls._system_libraries.get("libc")
        if libc is None:
            libc_name = find_library("c")
            if libc_name is None:  # pragma: no cover
                return None
            libc = ctypes.CDLL(libc_name, mode=_RTLD_NOLOAD)
            cls._system_libraries["libc"] = libc
        return libc

    @classmethod
    def _get_windll(cls, dll_name):
        
        dll = cls._system_libraries.get(dll_name)
        if dll is None:
            dll = ctypes.WinDLL("{}.dll".format(dll_name))
            cls._system_libraries[dll_name] = dll
        return dll

    @classmethod
    def _realpath(cls, filepath, cache_limit=10000):
        
        rpath = cls._realpaths.get(filepath)
        if rpath is None:
            rpath = os.path.realpath(filepath)
            if len(cls._realpaths) < cache_limit:
                # If we drop support for Python 2.7, we could use
                # functools.lru_cache with maxsize=10000 instead.
                cls._realpaths[filepath] = rpath
        return rpath


@_format_docstring(
    USER_APIS=", ".join('"{}"'.format(api) for api in _ALL_USER_APIS),
    INTERNAL_APIS=", ".join('"{}"'.format(api) for api in _ALL_INTERNAL_APIS))
class _Module(ABC):
    
    def __init__(self, filepath=None, prefix=None, user_api=None,
                 internal_api=None):
        self.filepath = filepath
        self.prefix = prefix
        self.user_api = user_api
        self.internal_api = internal_api
        self._dynlib = ctypes.CDLL(filepath, mode=_RTLD_NOLOAD)
        self.version = self.get_version()
        self.num_threads = self.get_num_threads()
        self._get_extra_info()

    def __eq__(self, other):
        return self.todict() == other.todict()

    def todict(self):
        
        return {k: v for k, v in vars(self).items() if not k.startswith("_")}

    @abstractmethod
    def get_version(self):
        
        pass  # pragma: no cover

    @abstractmethod
    def get_num_threads(self):
        
        pass  # pragma: no cover

    @abstractmethod
    def set_num_threads(self, num_threads):
        
        pass  # pragma: no cover

    @abstractmethod
    def _get_extra_info(self):
        
        pass  # pragma: no cover


class _OpenBLASModule(_Module):
    
    def get_version(self):
        # None means OpenBLAS is not loaded or version < 0.3.4, since OpenBLAS
        # did not expose its version before that.
        get_config = getattr(self._dynlib, "openblas_get_config",
                             lambda: None)
        get_config.restype = ctypes.c_char_p
        config = get_config().split()
        if config[0] == b"OpenBLAS":
            return config[1].decode("utf-8")
        return None

    def get_num_threads(self):
        get_func = getattr(self._dynlib, "openblas_get_num_threads",
                           lambda: None)
        return get_func()

    def set_num_threads(self, num_threads):
        set_func = getattr(self._dynlib, "openblas_set_num_threads",
                           lambda num_threads: None)
        return set_func(num_threads)

    def _get_extra_info(self):
        self.threading_layer = self.get_threading_layer()

    def get_threading_layer(self):
        
        threading_layer = self._dynlib.openblas_get_parallel()
        if threading_layer == 2:
            return "openmp"
        elif threading_layer == 1:
            return "pthreads"
        return "disabled"


class _BLISModule(_Module):
    
    def get_version(self):
        get_version_ = getattr(self._dynlib, "bli_info_get_version_str",
                               lambda: None)
        get_version_.restype = ctypes.c_char_p
        return get_version_().decode("utf-8")

    def get_num_threads(self):
        get_func = getattr(self._dynlib, "bli_thread_get_num_threads",
                           lambda: None)
        num_threads = get_func()
        
        return 1 if num_threads == -1 else num_threads

    def set_num_threads(self, num_threads):
        set_func = getattr(self._dynlib, "bli_thread_set_num_threads",
                           lambda num_threads: None)
        return set_func(num_threads)

    def _get_extra_info(self):
        self.threading_layer = self.get_threading_layer()

    def get_threading_layer(self):
        
        if self._dynlib.bli_info_get_enable_openmp():
            return "openmp"
        elif self._dynlib.bli_info_get_enable_pthreads():
            return "pthreads"
        return "disabled"


class _MKLModule(_Module):
   
    def get_version(self):
        res = ctypes.create_string_buffer(200)
        self._dynlib.mkl_get_version_string(res, 200)

        version = res.value.decode("utf-8")
        group = re.search(r"Version ([^ ]+) ", version)
        if group is not None:
            version = group.groups()[0]
        return version.strip()

    def get_num_threads(self):
        get_func = getattr(self._dynlib, "MKL_Get_Max_Threads", lambda: None)
        return get_func()

    def set_num_threads(self, num_threads):
        set_func = getattr(self._dynlib, "MKL_Set_Num_Threads",
                           lambda num_threads: None)
        return set_func(num_threads)

    def _get_extra_info(self):
        self.threading_layer = self.get_threading_layer()

    def get_threading_layer(self):
       
        set_threading_layer = getattr(self._dynlib, "MKL_Set_Threading_Layer",
                                      lambda layer: -1)
        layer_map = {0: "intel", 1: "sequential", 2: "pgi",
                     3: "gnu", 4: "tbb", -1: "not specified"}
        return layer_map[set_threading_layer(-1)]


class _OpenMPModule(_Module):
  
    def get_version(self):
        # There is no way to get the version number programmatically in OpenMP.
        return None

    def get_num_threads(self):
        get_func = getattr(self._dynlib, "omp_get_max_threads", lambda: None)
        return get_func()

    def set_num_threads(self, num_threads):
        set_func = getattr(self._dynlib, "omp_set_num_threads",
                           lambda num_threads: None)
        return set_func(num_threads)

    def _get_extra_info(self):
        pass


def _main():
    
    import argparse
    import importlib
    import json
    import sys

    parser = argparse.ArgumentParser(
        usage="python -m threadpoolctl -i numpy scipy.linalg xgboost",
        description="Display thread-pool information and exit.",
    )
    parser.add_argument(
        "-i", "--import", dest="modules", nargs="*", default=(),
        help="Python modules to import before introspecting thread-pools."
    )
    parser.add_argument(
        "-c", "--command",
        help="a Python statement to execute before introspecting"
             " thread-pools.")

    options = parser.parse_args(sys.argv[1:])
    for module in options.modules:
        try:
            importlib.import_module(module, package=None)
        except ImportError:
            print("WARNING: could not import", module, file=sys.stderr)

    if options.command:
        exec(options.command)

    print(json.dumps(threadpool_info(), indent=2))


if __name__ == "__main__":
    _main()
